/* automatically generated by rust-bindgen 0.69.4 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]


pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const OPUS_OK: u32 = 0;
pub const OPUS_BAD_ARG: i32 = -1;
pub const OPUS_BUFFER_TOO_SMALL: i32 = -2;
pub const OPUS_INTERNAL_ERROR: i32 = -3;
pub const OPUS_INVALID_PACKET: i32 = -4;
pub const OPUS_UNIMPLEMENTED: i32 = -5;
pub const OPUS_INVALID_STATE: i32 = -6;
pub const OPUS_ALLOC_FAIL: i32 = -7;
pub const OPUS_SET_APPLICATION_REQUEST: u32 = 4000;
pub const OPUS_GET_APPLICATION_REQUEST: u32 = 4001;
pub const OPUS_SET_BITRATE_REQUEST: u32 = 4002;
pub const OPUS_GET_BITRATE_REQUEST: u32 = 4003;
pub const OPUS_SET_MAX_BANDWIDTH_REQUEST: u32 = 4004;
pub const OPUS_GET_MAX_BANDWIDTH_REQUEST: u32 = 4005;
pub const OPUS_SET_VBR_REQUEST: u32 = 4006;
pub const OPUS_GET_VBR_REQUEST: u32 = 4007;
pub const OPUS_SET_BANDWIDTH_REQUEST: u32 = 4008;
pub const OPUS_GET_BANDWIDTH_REQUEST: u32 = 4009;
pub const OPUS_SET_COMPLEXITY_REQUEST: u32 = 4010;
pub const OPUS_GET_COMPLEXITY_REQUEST: u32 = 4011;
pub const OPUS_SET_INBAND_FEC_REQUEST: u32 = 4012;
pub const OPUS_GET_INBAND_FEC_REQUEST: u32 = 4013;
pub const OPUS_SET_PACKET_LOSS_PERC_REQUEST: u32 = 4014;
pub const OPUS_GET_PACKET_LOSS_PERC_REQUEST: u32 = 4015;
pub const OPUS_SET_DTX_REQUEST: u32 = 4016;
pub const OPUS_GET_DTX_REQUEST: u32 = 4017;
pub const OPUS_SET_VBR_CONSTRAINT_REQUEST: u32 = 4020;
pub const OPUS_GET_VBR_CONSTRAINT_REQUEST: u32 = 4021;
pub const OPUS_SET_FORCE_CHANNELS_REQUEST: u32 = 4022;
pub const OPUS_GET_FORCE_CHANNELS_REQUEST: u32 = 4023;
pub const OPUS_SET_SIGNAL_REQUEST: u32 = 4024;
pub const OPUS_GET_SIGNAL_REQUEST: u32 = 4025;
pub const OPUS_GET_LOOKAHEAD_REQUEST: u32 = 4027;
pub const OPUS_GET_SAMPLE_RATE_REQUEST: u32 = 4029;
pub const OPUS_GET_FINAL_RANGE_REQUEST: u32 = 4031;
pub const OPUS_GET_PITCH_REQUEST: u32 = 4033;
pub const OPUS_SET_GAIN_REQUEST: u32 = 4034;
pub const OPUS_GET_GAIN_REQUEST: u32 = 4045;
pub const OPUS_SET_LSB_DEPTH_REQUEST: u32 = 4036;
pub const OPUS_GET_LSB_DEPTH_REQUEST: u32 = 4037;
pub const OPUS_GET_LAST_PACKET_DURATION_REQUEST: u32 = 4039;
pub const OPUS_SET_EXPERT_FRAME_DURATION_REQUEST: u32 = 4040;
pub const OPUS_GET_EXPERT_FRAME_DURATION_REQUEST: u32 = 4041;
pub const OPUS_SET_PREDICTION_DISABLED_REQUEST: u32 = 4042;
pub const OPUS_GET_PREDICTION_DISABLED_REQUEST: u32 = 4043;
pub const OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST: u32 = 4046;
pub const OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST: u32 = 4047;
pub const OPUS_GET_IN_DTX_REQUEST: u32 = 4049;
pub const OPUS_AUTO: i32 = -1000;
pub const OPUS_BITRATE_MAX: i32 = -1;
pub const OPUS_APPLICATION_VOIP: u32 = 2048;
pub const OPUS_APPLICATION_AUDIO: u32 = 2049;
pub const OPUS_APPLICATION_RESTRICTED_LOWDELAY: u32 = 2051;
pub const OPUS_SIGNAL_VOICE: u32 = 3001;
pub const OPUS_SIGNAL_MUSIC: u32 = 3002;
pub const OPUS_BANDWIDTH_NARROWBAND: u32 = 1101;
pub const OPUS_BANDWIDTH_MEDIUMBAND: u32 = 1102;
pub const OPUS_BANDWIDTH_WIDEBAND: u32 = 1103;
pub const OPUS_BANDWIDTH_SUPERWIDEBAND: u32 = 1104;
pub const OPUS_BANDWIDTH_FULLBAND: u32 = 1105;
pub const OPUS_FRAMESIZE_ARG: u32 = 5000;
pub const OPUS_FRAMESIZE_2_5_MS: u32 = 5001;
pub const OPUS_FRAMESIZE_5_MS: u32 = 5002;
pub const OPUS_FRAMESIZE_10_MS: u32 = 5003;
pub const OPUS_FRAMESIZE_20_MS: u32 = 5004;
pub const OPUS_FRAMESIZE_40_MS: u32 = 5005;
pub const OPUS_FRAMESIZE_60_MS: u32 = 5006;
pub const OPUS_FRAMESIZE_80_MS: u32 = 5007;
pub const OPUS_FRAMESIZE_100_MS: u32 = 5008;
pub const OPUS_FRAMESIZE_120_MS: u32 = 5009;
pub const OPUS_RESET_STATE: u32 = 4028;
pub const OPUS_MULTISTREAM_GET_ENCODER_STATE_REQUEST: u32 = 5120;
pub const OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST: u32 = 5122;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type opus_int8 = i8;
pub type opus_uint8 = u8;
pub type opus_int16 = i16;
pub type opus_uint16 = u16;
pub type opus_int32 = i32;
pub type opus_uint32 = u32;
pub type opus_int64 = i64;
pub type opus_uint64 = u64;
extern "C" {
    #[doc = " Converts an opus error code into a human readable string.\n\n @param[in] error <tt>int</tt>: Error number\n @returns Error string"]
    pub fn opus_strerror(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the libopus version string.\n\n Applications may look for the substring \"-fixed\" in the version string to\n determine whether they have a fixed-point or floating-point build at\n runtime.\n\n @returns Version string"]
    pub fn opus_get_version_string() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusEncoder {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Gets the size of an <code>OpusEncoder</code> structure.\n @param[in] channels <tt>int</tt>: Number of channels.\n                                   This must be 1 or 2.\n @returns The size in bytes."]
    pub fn opus_encoder_get_size(channels: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocates and initializes an encoder state.\n There are three coding modes:\n\n @ref OPUS_APPLICATION_VOIP gives best quality at a given bitrate for voice\n    signals. It enhances the  input signal by high-pass filtering and\n    emphasizing formants and harmonics. Optionally  it includes in-band\n    forward error correction to protect against packet loss. Use this\n    mode for typical VoIP applications. Because of the enhancement,\n    even at high bitrates the output may sound different from the input.\n\n @ref OPUS_APPLICATION_AUDIO gives best quality at a given bitrate for most\n    non-voice signals like music. Use this mode for music and mixed\n    (music/voice) content, broadcast, and applications requiring less\n    than 15 ms of coding delay.\n\n @ref OPUS_APPLICATION_RESTRICTED_LOWDELAY configures low-delay mode that\n    disables the speech-optimized mode in exchange for slightly reduced delay.\n    This mode can only be set on an newly initialized or freshly reset encoder\n    because it changes the codec delay.\n\n This is useful when the caller knows that the speech-optimized modes will not be needed (use with caution).\n @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)\n                                     This must be one of 8000, 12000, 16000,\n                                     24000, or 48000.\n @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal\n @param [in] application <tt>int</tt>: Coding mode (@ref OPUS_APPLICATION_VOIP/@ref OPUS_APPLICATION_AUDIO/@ref OPUS_APPLICATION_RESTRICTED_LOWDELAY)\n @param [out] error <tt>int*</tt>: @ref opus_errorcodes\n @note Regardless of the sampling rate and number channels selected, the Opus encoder\n can switch to a lower audio bandwidth or number of channels if the bitrate\n selected is too low. This also means that it is safe to always use 48 kHz stereo input\n and let the encoder optimize the encoding."]
    pub fn opus_encoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        application: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusEncoder;
}
extern "C" {
    #[doc = " Initializes a previously allocated encoder state\n The memory pointed to by st must be at least the size returned by opus_encoder_get_size().\n This is intended for applications which use their own allocator instead of malloc.\n @see opus_encoder_create(),opus_encoder_get_size()\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n @param [in] st <tt>OpusEncoder*</tt>: Encoder state\n @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)\n                                      This must be one of 8000, 12000, 16000,\n                                      24000, or 48000.\n @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal\n @param [in] application <tt>int</tt>: Coding mode (OPUS_APPLICATION_VOIP/OPUS_APPLICATION_AUDIO/OPUS_APPLICATION_RESTRICTED_LOWDELAY)\n @retval #OPUS_OK Success or @ref opus_errorcodes"]
    pub fn opus_encoder_init(
        st: *mut OpusEncoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        application: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes an Opus frame.\n @param [in] st <tt>OpusEncoder*</tt>: Encoder state\n @param [in] pcm <tt>opus_int16*</tt>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(opus_int16)\n @param [in] frame_size <tt>int</tt>: Number of samples per channel in the\n                                      input signal.\n                                      This must be an Opus frame size for\n                                      the encoder's sampling rate.\n                                      For example, at 48 kHz the permitted\n                                      values are 120, 240, 480, 960, 1920,\n                                      and 2880.\n                                      Passing in a duration of less than\n                                      10 ms (480 samples at 48 kHz) will\n                                      prevent the encoder from using the LPC\n                                      or hybrid modes.\n @param [out] data <tt>unsigned char*</tt>: Output payload.\n                                            This must contain storage for at\n                                            least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_encode(
        st: *mut OpusEncoder,
        pcm: *const opus_int16,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> opus_int32;
}
extern "C" {
    #[doc = " Encodes an Opus frame from floating point input.\n @param [in] st <tt>OpusEncoder*</tt>: Encoder state\n @param [in] pcm <tt>float*</tt>: Input in float format (interleaved if 2 channels), with a normal range of +/-1.0.\n          Samples with a range beyond +/-1.0 are supported but will\n          be clipped by decoders using the integer API and should\n          only be used if it is known that the far end supports\n          extended dynamic range.\n          length is frame_size*channels*sizeof(float)\n @param [in] frame_size <tt>int</tt>: Number of samples per channel in the\n                                      input signal.\n                                      This must be an Opus frame size for\n                                      the encoder's sampling rate.\n                                      For example, at 48 kHz the permitted\n                                      values are 120, 240, 480, 960, 1920,\n                                      and 2880.\n                                      Passing in a duration of less than\n                                      10 ms (480 samples at 48 kHz) will\n                                      prevent the encoder from using the LPC\n                                      or hybrid modes.\n @param [out] data <tt>unsigned char*</tt>: Output payload.\n                                            This must contain storage for at\n                                            least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_encode_float(
        st: *mut OpusEncoder,
        pcm: *const f32,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> opus_int32;
}
extern "C" {
    #[doc = " Frees an <code>OpusEncoder</code> allocated by opus_encoder_create().\n @param[in] st <tt>OpusEncoder*</tt>: State to be freed."]
    pub fn opus_encoder_destroy(st: *mut OpusEncoder);
}
extern "C" {
    #[doc = " Perform a CTL function on an Opus encoder.\n\n Generally the request and subsequent arguments are generated\n by a convenience macro.\n @param st <tt>OpusEncoder*</tt>: Encoder state.\n @param request This and all remaining parameters should be replaced by one\n                of the convenience macros in @ref opus_genericctls or\n                @ref opus_encoderctls.\n @see opus_genericctls\n @see opus_encoderctls"]
    pub fn opus_encoder_ctl(
        st: *mut OpusEncoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusDecoder {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Gets the size of an <code>OpusDecoder</code> structure.\n @param [in] channels <tt>int</tt>: Number of channels.\n                                    This must be 1 or 2.\n @returns The size in bytes."]
    pub fn opus_decoder_get_size(channels: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocates and initializes a decoder state.\n @param [in] Fs <tt>opus_int32</tt>: Sample rate to decode at (Hz).\n                                     This must be one of 8000, 12000, 16000,\n                                     24000, or 48000.\n @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode\n @param [out] error <tt>int*</tt>: #OPUS_OK Success or @ref opus_errorcodes\n\n Internally Opus stores data at 48000 Hz, so that should be the default\n value for Fs. However, the decoder can efficiently decode to buffers\n at 8, 12, 16, and 24 kHz so if for some reason the caller cannot use\n data at the full sample rate, or knows the compressed data doesn't\n use the full frequency range, it can request decoding at a reduced\n rate. Likewise, the decoder is capable of filling in either mono or\n interleaved stereo pcm buffers, at the caller's request."]
    pub fn opus_decoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusDecoder;
}
extern "C" {
    #[doc = " Initializes a previously allocated decoder state.\n The state must be at least the size returned by opus_decoder_get_size().\n This is intended for applications which use their own allocator instead of malloc. @see opus_decoder_create,opus_decoder_get_size\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n @param [in] st <tt>OpusDecoder*</tt>: Decoder state.\n @param [in] Fs <tt>opus_int32</tt>: Sampling rate to decode to (Hz).\n                                     This must be one of 8000, 12000, 16000,\n                                     24000, or 48000.\n @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode\n @retval #OPUS_OK Success or @ref opus_errorcodes"]
    pub fn opus_decoder_init(
        st: *mut OpusDecoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode an Opus packet.\n @param [in] st <tt>OpusDecoder*</tt>: Decoder state\n @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss\n @param [in] len <tt>opus_int32</tt>: Number of bytes in payload*\n @param [out] pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length\n  is frame_size*channels*sizeof(opus_int16)\n @param [in] frame_size Number of samples per channel of available space in \\a pcm.\n  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will\n  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),\n  then frame_size needs to be exactly the duration of audio that is missing, otherwise the\n  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and\n  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.\n @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be\n  decoded. If no such data is available, the frame is decoded as if it were lost.\n @returns Number of decoded samples or @ref opus_errorcodes"]
    pub fn opus_decode(
        st: *mut OpusDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut opus_int16,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode an Opus packet with floating point output.\n @param [in] st <tt>OpusDecoder*</tt>: Decoder state\n @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss\n @param [in] len <tt>opus_int32</tt>: Number of bytes in payload\n @param [out] pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length\n  is frame_size*channels*sizeof(float)\n @param [in] frame_size Number of samples per channel of available space in \\a pcm.\n  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will\n  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),\n  then frame_size needs to be exactly the duration of audio that is missing, otherwise the\n  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and\n  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.\n @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be\n  decoded. If no such data is available the frame is decoded as if it were lost.\n @returns Number of decoded samples or @ref opus_errorcodes"]
    pub fn opus_decode_float(
        st: *mut OpusDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut f32,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform a CTL function on an Opus decoder.\n\n Generally the request and subsequent arguments are generated\n by a convenience macro.\n @param st <tt>OpusDecoder*</tt>: Decoder state.\n @param request This and all remaining parameters should be replaced by one\n                of the convenience macros in @ref opus_genericctls or\n                @ref opus_decoderctls.\n @see opus_genericctls\n @see opus_decoderctls"]
    pub fn opus_decoder_ctl(
        st: *mut OpusDecoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Frees an <code>OpusDecoder</code> allocated by opus_decoder_create().\n @param[in] st <tt>OpusDecoder*</tt>: State to be freed."]
    pub fn opus_decoder_destroy(st: *mut OpusDecoder);
}
extern "C" {
    #[doc = " Parse an opus packet into one or more frames.\n Opus_decode will perform this operation internally so most applications do\n not need to use this function.\n This function does not copy the frames, the returned pointers are pointers into\n the input packet.\n @param [in] data <tt>char*</tt>: Opus packet to be parsed\n @param [in] len <tt>opus_int32</tt>: size of data\n @param [out] out_toc <tt>char*</tt>: TOC pointer\n @param [out] frames <tt>char*[48]</tt> encapsulated frames\n @param [out] size <tt>opus_int16[48]</tt> sizes of the encapsulated frames\n @param [out] payload_offset <tt>int*</tt>: returns the position of the payload within the packet (in bytes)\n @returns number of frames"]
    pub fn opus_packet_parse(
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        out_toc: *mut ::std::os::raw::c_uchar,
        frames: *mut *const ::std::os::raw::c_uchar,
        size: *mut opus_int16,
        payload_offset: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the bandwidth of an Opus packet.\n @param [in] data <tt>char*</tt>: Opus packet\n @retval OPUS_BANDWIDTH_NARROWBAND Narrowband (4kHz bandpass)\n @retval OPUS_BANDWIDTH_MEDIUMBAND Mediumband (6kHz bandpass)\n @retval OPUS_BANDWIDTH_WIDEBAND Wideband (8kHz bandpass)\n @retval OPUS_BANDWIDTH_SUPERWIDEBAND Superwideband (12kHz bandpass)\n @retval OPUS_BANDWIDTH_FULLBAND Fullband (20kHz bandpass)\n @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_get_bandwidth(data: *const ::std::os::raw::c_uchar)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of samples per frame from an Opus packet.\n @param [in] data <tt>char*</tt>: Opus packet.\n                                  This must contain at least one byte of\n                                  data.\n @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz.\n                                     This must be a multiple of 400, or\n                                     inaccurate results will be returned.\n @returns Number of samples per frame."]
    pub fn opus_packet_get_samples_per_frame(
        data: *const ::std::os::raw::c_uchar,
        Fs: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of channels from an Opus packet.\n @param [in] data <tt>char*</tt>: Opus packet\n @returns Number of channels\n @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_get_nb_channels(
        data: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of frames in an Opus packet.\n @param [in] packet <tt>char*</tt>: Opus packet\n @param [in] len <tt>opus_int32</tt>: Length of packet\n @returns Number of frames\n @retval OPUS_BAD_ARG Insufficient data was passed to the function\n @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_get_nb_frames(
        packet: *const ::std::os::raw::c_uchar,
        len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of samples of an Opus packet.\n @param [in] packet <tt>char*</tt>: Opus packet\n @param [in] len <tt>opus_int32</tt>: Length of packet\n @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz.\n                                     This must be a multiple of 400, or\n                                     inaccurate results will be returned.\n @returns Number of samples\n @retval OPUS_BAD_ARG Insufficient data was passed to the function\n @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_packet_get_nb_samples(
        packet: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        Fs: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of samples of an Opus packet.\n @param [in] dec <tt>OpusDecoder*</tt>: Decoder state\n @param [in] packet <tt>char*</tt>: Opus packet\n @param [in] len <tt>opus_int32</tt>: Length of packet\n @returns Number of samples\n @retval OPUS_BAD_ARG Insufficient data was passed to the function\n @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type"]
    pub fn opus_decoder_get_nb_samples(
        dec: *const OpusDecoder,
        packet: *const ::std::os::raw::c_uchar,
        len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Applies soft-clipping to bring a float signal within the [-1,1] range. If\n the signal is already in that range, nothing is done. If there are values\n outside of [-1,1], then the signal is clipped as smoothly as possible to\n both fit in the range and avoid creating excessive distortion in the\n process.\n @param [in,out] pcm <tt>float*</tt>: Input PCM and modified PCM\n @param [in] frame_size <tt>int</tt> Number of samples per channel to process\n @param [in] channels <tt>int</tt>: Number of channels\n @param [in,out] softclip_mem <tt>float*</tt>: State memory for the soft clipping process (one float per channel, initialized to zero)"]
    pub fn opus_pcm_soft_clip(
        pcm: *mut f32,
        frame_size: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        softclip_mem: *mut f32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusRepacketizer {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Gets the size of an <code>OpusRepacketizer</code> structure.\n @returns The size in bytes."]
    pub fn opus_repacketizer_get_size() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " (Re)initializes a previously allocated repacketizer state.\n The state must be at least the size returned by opus_repacketizer_get_size().\n This can be used for applications which use their own allocator instead of\n malloc().\n It must also be called to reset the queue of packets waiting to be\n repacketized, which is necessary if the maximum packet duration of 120 ms\n is reached or if you wish to submit packets with a different Opus\n configuration (coding mode, audio bandwidth, frame size, or channel count).\n Failure to do so will prevent a new packet from being added with\n opus_repacketizer_cat().\n @see opus_repacketizer_create\n @see opus_repacketizer_get_size\n @see opus_repacketizer_cat\n @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to\n                                       (re)initialize.\n @returns A pointer to the same repacketizer state that was passed in."]
    pub fn opus_repacketizer_init(rp: *mut OpusRepacketizer) -> *mut OpusRepacketizer;
}
extern "C" {
    #[doc = " Allocates memory and initializes the new repacketizer with\n opus_repacketizer_init()."]
    pub fn opus_repacketizer_create() -> *mut OpusRepacketizer;
}
extern "C" {
    #[doc = " Frees an <code>OpusRepacketizer</code> allocated by\n opus_repacketizer_create().\n @param[in] rp <tt>OpusRepacketizer*</tt>: State to be freed."]
    pub fn opus_repacketizer_destroy(rp: *mut OpusRepacketizer);
}
extern "C" {
    #[doc = " Add a packet to the current repacketizer state.\n This packet must match the configuration of any packets already submitted\n for repacketization since the last call to opus_repacketizer_init().\n This means that it must have the same coding mode, audio bandwidth, frame\n size, and channel count.\n This can be checked in advance by examining the top 6 bits of the first\n byte of the packet, and ensuring they match the top 6 bits of the first\n byte of any previously submitted packet.\n The total duration of audio in the repacketizer state also must not exceed\n 120 ms, the maximum duration of a single packet, after adding this packet.\n\n The contents of the current repacketizer state can be extracted into new\n packets using opus_repacketizer_out() or opus_repacketizer_out_range().\n\n In order to add a packet with a different configuration or to add more\n audio beyond 120 ms, you must clear the repacketizer state by calling\n opus_repacketizer_init().\n If a packet is too large to add to the current repacketizer state, no part\n of it is added, even if it contains multiple frames, some of which might\n fit.\n If you wish to be able to add parts of such packets, you should first use\n another repacketizer to split the packet into pieces and add them\n individually.\n @see opus_repacketizer_out_range\n @see opus_repacketizer_out\n @see opus_repacketizer_init\n @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to which to\n                                       add the packet.\n @param[in] data <tt>const unsigned char*</tt>: The packet data.\n                                                The application must ensure\n                                                this pointer remains valid\n                                                until the next call to\n                                                opus_repacketizer_init() or\n                                                opus_repacketizer_destroy().\n @param len <tt>opus_int32</tt>: The number of bytes in the packet data.\n @returns An error code indicating whether or not the operation succeeded.\n @retval #OPUS_OK The packet's contents have been added to the repacketizer\n                  state.\n @retval #OPUS_INVALID_PACKET The packet did not have a valid TOC sequence,\n                              the packet's TOC sequence was not compatible\n                              with previously submitted packets (because\n                              the coding mode, audio bandwidth, frame size,\n                              or channel count did not match), or adding\n                              this packet would increase the total amount of\n                              audio stored in the repacketizer state to more\n                              than 120 ms."]
    pub fn opus_repacketizer_cat(
        rp: *mut OpusRepacketizer,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct a new packet from data previously submitted to the repacketizer\n state via opus_repacketizer_cat().\n @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to\n                                       construct the new packet.\n @param begin <tt>int</tt>: The index of the first frame in the current\n                            repacketizer state to include in the output.\n @param end <tt>int</tt>: One past the index of the last frame in the\n                          current repacketizer state to include in the\n                          output.\n @param[out] data <tt>const unsigned char*</tt>: The buffer in which to\n                                                 store the output packet.\n @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in\n                                    the output buffer. In order to guarantee\n                                    success, this should be at least\n                                    <code>1276</code> for a single frame,\n                                    or for multiple frames,\n                                    <code>1277*(end-begin)</code>.\n                                    However, <code>1*(end-begin)</code> plus\n                                    the size of all packet data submitted to\n                                    the repacketizer since the last call to\n                                    opus_repacketizer_init() or\n                                    opus_repacketizer_create() is also\n                                    sufficient, and possibly much smaller.\n @returns The total size of the output packet on success, or an error code\n          on failure.\n @retval #OPUS_BAD_ARG <code>[begin,end)</code> was an invalid range of\n                       frames (begin < 0, begin >= end, or end >\n                       opus_repacketizer_get_nb_frames()).\n @retval #OPUS_BUFFER_TOO_SMALL \\a maxlen was insufficient to contain the\n                                complete output packet."]
    pub fn opus_repacketizer_out_range(
        rp: *mut OpusRepacketizer,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        maxlen: opus_int32,
    ) -> opus_int32;
}
extern "C" {
    #[doc = " Return the total number of frames contained in packet data submitted to\n the repacketizer state so far via opus_repacketizer_cat() since the last\n call to opus_repacketizer_init() or opus_repacketizer_create().\n This defines the valid range of packets that can be extracted with\n opus_repacketizer_out_range() or opus_repacketizer_out().\n @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state containing the\n                                       frames.\n @returns The total number of frames contained in the packet data submitted\n          to the repacketizer state."]
    pub fn opus_repacketizer_get_nb_frames(rp: *mut OpusRepacketizer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct a new packet from data previously submitted to the repacketizer\n state via opus_repacketizer_cat().\n This is a convenience routine that returns all the data submitted so far\n in a single packet.\n It is equivalent to calling\n @code\n opus_repacketizer_out_range(rp, 0, opus_repacketizer_get_nb_frames(rp),\n                             data, maxlen)\n @endcode\n @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to\n                                       construct the new packet.\n @param[out] data <tt>const unsigned char*</tt>: The buffer in which to\n                                                 store the output packet.\n @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in\n                                    the output buffer. In order to guarantee\n                                    success, this should be at least\n                                    <code>1277*opus_repacketizer_get_nb_frames(rp)</code>.\n                                    However,\n                                    <code>1*opus_repacketizer_get_nb_frames(rp)</code>\n                                    plus the size of all packet data\n                                    submitted to the repacketizer since the\n                                    last call to opus_repacketizer_init() or\n                                    opus_repacketizer_create() is also\n                                    sufficient, and possibly much smaller.\n @returns The total size of the output packet on success, or an error code\n          on failure.\n @retval #OPUS_BUFFER_TOO_SMALL \\a maxlen was insufficient to contain the\n                                complete output packet."]
    pub fn opus_repacketizer_out(
        rp: *mut OpusRepacketizer,
        data: *mut ::std::os::raw::c_uchar,
        maxlen: opus_int32,
    ) -> opus_int32;
}
extern "C" {
    #[doc = " Pads a given Opus packet to a larger size (possibly changing the TOC sequence).\n @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the\n                                                   packet to pad.\n @param len <tt>opus_int32</tt>: The size of the packet.\n                                 This must be at least 1.\n @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding.\n                                 This must be at least as large as len.\n @returns an error code\n @retval #OPUS_OK \\a on success.\n @retval #OPUS_BAD_ARG \\a len was less than 1 or new_len was less than len.\n @retval #OPUS_INVALID_PACKET \\a data did not contain a valid Opus packet."]
    pub fn opus_packet_pad(
        data: *mut ::std::os::raw::c_uchar,
        len: opus_int32,
        new_len: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove all padding from a given Opus packet and rewrite the TOC sequence to\n minimize space usage.\n @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the\n                                                   packet to strip.\n @param len <tt>opus_int32</tt>: The size of the packet.\n                                 This must be at least 1.\n @returns The new size of the output packet on success, or an error code\n          on failure.\n @retval #OPUS_BAD_ARG \\a len was less than 1.\n @retval #OPUS_INVALID_PACKET \\a data did not contain a valid Opus packet."]
    pub fn opus_packet_unpad(data: *mut ::std::os::raw::c_uchar, len: opus_int32) -> opus_int32;
}
extern "C" {
    #[doc = " Pads a given Opus multi-stream packet to a larger size (possibly changing the TOC sequence).\n @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the\n                                                   packet to pad.\n @param len <tt>opus_int32</tt>: The size of the packet.\n                                 This must be at least 1.\n @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding.\n                                 This must be at least 1.\n @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet.\n                                 This must be at least as large as len.\n @returns an error code\n @retval #OPUS_OK \\a on success.\n @retval #OPUS_BAD_ARG \\a len was less than 1.\n @retval #OPUS_INVALID_PACKET \\a data did not contain a valid Opus packet."]
    pub fn opus_multistream_packet_pad(
        data: *mut ::std::os::raw::c_uchar,
        len: opus_int32,
        new_len: opus_int32,
        nb_streams: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove all padding from a given Opus multi-stream packet and rewrite the TOC sequence to\n minimize space usage.\n @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the\n                                                   packet to strip.\n @param len <tt>opus_int32</tt>: The size of the packet.\n                                 This must be at least 1.\n @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet.\n                                 This must be at least 1.\n @returns The new size of the output packet on success, or an error code\n          on failure.\n @retval #OPUS_BAD_ARG \\a len was less than 1 or new_len was less than len.\n @retval #OPUS_INVALID_PACKET \\a data did not contain a valid Opus packet."]
    pub fn opus_multistream_packet_unpad(
        data: *mut ::std::os::raw::c_uchar,
        len: opus_int32,
        nb_streams: ::std::os::raw::c_int,
    ) -> opus_int32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusMSEncoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpusMSDecoder {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Gets the size of an OpusMSEncoder structure.\n @param streams <tt>int</tt>: The total number of streams to encode from the\n                              input.\n                              This must be no more than 255.\n @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams\n                                      to encode.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      encoded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than 255.\n @returns The size in bytes on success, or a negative error code\n          (see @ref opus_errorcodes) on error."]
    pub fn opus_multistream_encoder_get_size(
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
    ) -> opus_int32;
}
extern "C" {
    pub fn opus_multistream_surround_encoder_get_size(
        channels: ::std::os::raw::c_int,
        mapping_family: ::std::os::raw::c_int,
    ) -> opus_int32;
}
extern "C" {
    #[doc = " Allocates and initializes a multistream encoder state.\n Call opus_multistream_encoder_destroy() to release\n this object when finished.\n @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).\n                                This must be one of 8000, 12000, 16000,\n                                24000, or 48000.\n @param channels <tt>int</tt>: Number of channels in the input signal.\n                               This must be at most 255.\n                               It may be greater than the number of\n                               coded channels (<code>streams +\n                               coupled_streams</code>).\n @param streams <tt>int</tt>: The total number of streams to encode from the\n                              input.\n                              This must be no more than the number of channels.\n @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams\n                                      to encode.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      encoded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than the number of input channels.\n @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from\n                    encoded channels to input channels, as described in\n                    @ref opus_multistream. As an extra constraint, the\n                    multistream encoder does not allow encoding coupled\n                    streams for which one channel is unused since this\n                    is never a good idea.\n @param application <tt>int</tt>: The target encoder application.\n                                  This must be one of the following:\n <dl>\n <dt>#OPUS_APPLICATION_VOIP</dt>\n <dd>Process signal for improved speech intelligibility.</dd>\n <dt>#OPUS_APPLICATION_AUDIO</dt>\n <dd>Favor faithfulness to the original input.</dd>\n <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>\n <dd>Configure the minimum possible coding delay by disabling certain modes\n of operation.</dd>\n </dl>\n @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error\n                                   code (see @ref opus_errorcodes) on\n                                   failure."]
    pub fn opus_multistream_encoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_uchar,
        application: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusMSEncoder;
}
extern "C" {
    pub fn opus_multistream_surround_encoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        mapping_family: ::std::os::raw::c_int,
        streams: *mut ::std::os::raw::c_int,
        coupled_streams: *mut ::std::os::raw::c_int,
        mapping: *mut ::std::os::raw::c_uchar,
        application: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusMSEncoder;
}
extern "C" {
    #[doc = " Initialize a previously allocated multistream encoder state.\n The memory pointed to by \\a st must be at least the size returned by\n opus_multistream_encoder_get_size().\n This is intended for applications which use their own allocator instead of\n malloc.\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n @see opus_multistream_encoder_create\n @see opus_multistream_encoder_get_size\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state to initialize.\n @param Fs <tt>opus_int32</tt>: Sampling rate of the input signal (in Hz).\n                                This must be one of 8000, 12000, 16000,\n                                24000, or 48000.\n @param channels <tt>int</tt>: Number of channels in the input signal.\n                               This must be at most 255.\n                               It may be greater than the number of\n                               coded channels (<code>streams +\n                               coupled_streams</code>).\n @param streams <tt>int</tt>: The total number of streams to encode from the\n                              input.\n                              This must be no more than the number of channels.\n @param coupled_streams <tt>int</tt>: Number of coupled (2 channel) streams\n                                      to encode.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      encoded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than the number of input channels.\n @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from\n                    encoded channels to input channels, as described in\n                    @ref opus_multistream. As an extra constraint, the\n                    multistream encoder does not allow encoding coupled\n                    streams for which one channel is unused since this\n                    is never a good idea.\n @param application <tt>int</tt>: The target encoder application.\n                                  This must be one of the following:\n <dl>\n <dt>#OPUS_APPLICATION_VOIP</dt>\n <dd>Process signal for improved speech intelligibility.</dd>\n <dt>#OPUS_APPLICATION_AUDIO</dt>\n <dd>Favor faithfulness to the original input.</dd>\n <dt>#OPUS_APPLICATION_RESTRICTED_LOWDELAY</dt>\n <dd>Configure the minimum possible coding delay by disabling certain modes\n of operation.</dd>\n </dl>\n @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)\n          on failure."]
    pub fn opus_multistream_encoder_init(
        st: *mut OpusMSEncoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_uchar,
        application: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn opus_multistream_surround_encoder_init(
        st: *mut OpusMSEncoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        mapping_family: ::std::os::raw::c_int,
        streams: *mut ::std::os::raw::c_int,
        coupled_streams: *mut ::std::os::raw::c_int,
        mapping: *mut ::std::os::raw::c_uchar,
        application: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes a multistream Opus frame.\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state.\n @param[in] pcm <tt>const opus_int16*</tt>: The input signal as interleaved\n                                            samples.\n                                            This must contain\n                                            <code>frame_size*channels</code>\n                                            samples.\n @param frame_size <tt>int</tt>: Number of samples per channel in the input\n                                 signal.\n                                 This must be an Opus frame size for the\n                                 encoder's sampling rate.\n                                 For example, at 48 kHz the permitted values\n                                 are 120, 240, 480, 960, 1920, and 2880.\n                                 Passing in a duration of less than 10 ms\n                                 (480 samples at 48 kHz) will prevent the\n                                 encoder from using the LPC or hybrid modes.\n @param[out] data <tt>unsigned char*</tt>: Output payload.\n                                           This must contain storage for at\n                                           least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_encode(
        st: *mut OpusMSEncoder,
        pcm: *const opus_int16,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes a multistream Opus frame from floating point input.\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state.\n @param[in] pcm <tt>const float*</tt>: The input signal as interleaved\n                                       samples with a normal range of\n                                       +/-1.0.\n                                       Samples with a range beyond +/-1.0\n                                       are supported but will be clipped by\n                                       decoders using the integer API and\n                                       should only be used if it is known\n                                       that the far end supports extended\n                                       dynamic range.\n                                       This must contain\n                                       <code>frame_size*channels</code>\n                                       samples.\n @param frame_size <tt>int</tt>: Number of samples per channel in the input\n                                 signal.\n                                 This must be an Opus frame size for the\n                                 encoder's sampling rate.\n                                 For example, at 48 kHz the permitted values\n                                 are 120, 240, 480, 960, 1920, and 2880.\n                                 Passing in a duration of less than 10 ms\n                                 (480 samples at 48 kHz) will prevent the\n                                 encoder from using the LPC or hybrid modes.\n @param[out] data <tt>unsigned char*</tt>: Output payload.\n                                           This must contain storage for at\n                                           least \\a max_data_bytes.\n @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated\n                                                 memory for the output\n                                                 payload. This may be\n                                                 used to impose an upper limit on\n                                                 the instant bitrate, but should\n                                                 not be used as the only bitrate\n                                                 control. Use #OPUS_SET_BITRATE to\n                                                 control the bitrate.\n @returns The length of the encoded packet (in bytes) on success or a\n          negative error code (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_encode_float(
        st: *mut OpusMSEncoder,
        pcm: *const f32,
        frame_size: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_uchar,
        max_data_bytes: opus_int32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Frees an <code>OpusMSEncoder</code> allocated by\n opus_multistream_encoder_create().\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state to be freed."]
    pub fn opus_multistream_encoder_destroy(st: *mut OpusMSEncoder);
}
extern "C" {
    #[doc = " Perform a CTL function on a multistream Opus encoder.\n\n Generally the request and subsequent arguments are generated by a\n convenience macro.\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state.\n @param request This and all remaining parameters should be replaced by one\n                of the convenience macros in @ref opus_genericctls,\n                @ref opus_encoderctls, or @ref opus_multistream_ctls.\n @see opus_genericctls\n @see opus_encoderctls\n @see opus_multistream_ctls"]
    pub fn opus_multistream_encoder_ctl(
        st: *mut OpusMSEncoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the size of an <code>OpusMSDecoder</code> structure.\n @param streams <tt>int</tt>: The total number of streams coded in the\n                              input.\n                              This must be no more than 255.\n @param coupled_streams <tt>int</tt>: Number streams to decode as coupled\n                                      (2 channel) streams.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      coded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than 255.\n @returns The size in bytes on success, or a negative error code\n          (see @ref opus_errorcodes) on error."]
    pub fn opus_multistream_decoder_get_size(
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
    ) -> opus_int32;
}
extern "C" {
    #[doc = " Allocates and initializes a multistream decoder state.\n Call opus_multistream_decoder_destroy() to release\n this object when finished.\n @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).\n                                This must be one of 8000, 12000, 16000,\n                                24000, or 48000.\n @param channels <tt>int</tt>: Number of channels to output.\n                               This must be at most 255.\n                               It may be different from the number of coded\n                               channels (<code>streams +\n                               coupled_streams</code>).\n @param streams <tt>int</tt>: The total number of streams coded in the\n                              input.\n                              This must be no more than 255.\n @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled\n                                      (2 channel) streams.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      coded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than 255.\n @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from\n                    coded channels to output channels, as described in\n                    @ref opus_multistream.\n @param[out] error <tt>int *</tt>: Returns #OPUS_OK on success, or an error\n                                   code (see @ref opus_errorcodes) on\n                                   failure."]
    pub fn opus_multistream_decoder_create(
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_uchar,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut OpusMSDecoder;
}
extern "C" {
    #[doc = " Intialize a previously allocated decoder state object.\n The memory pointed to by \\a st must be at least the size returned by\n opus_multistream_encoder_get_size().\n This is intended for applications which use their own allocator instead of\n malloc.\n To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.\n @see opus_multistream_decoder_create\n @see opus_multistream_deocder_get_size\n @param st <tt>OpusMSEncoder*</tt>: Multistream encoder state to initialize.\n @param Fs <tt>opus_int32</tt>: Sampling rate to decode at (in Hz).\n                                This must be one of 8000, 12000, 16000,\n                                24000, or 48000.\n @param channels <tt>int</tt>: Number of channels to output.\n                               This must be at most 255.\n                               It may be different from the number of coded\n                               channels (<code>streams +\n                               coupled_streams</code>).\n @param streams <tt>int</tt>: The total number of streams coded in the\n                              input.\n                              This must be no more than 255.\n @param coupled_streams <tt>int</tt>: Number of streams to decode as coupled\n                                      (2 channel) streams.\n                                      This must be no larger than the total\n                                      number of streams.\n                                      Additionally, The total number of\n                                      coded channels (<code>streams +\n                                      coupled_streams</code>) must be no\n                                      more than 255.\n @param[in] mapping <code>const unsigned char[channels]</code>: Mapping from\n                    coded channels to output channels, as described in\n                    @ref opus_multistream.\n @returns #OPUS_OK on success, or an error code (see @ref opus_errorcodes)\n          on failure."]
    pub fn opus_multistream_decoder_init(
        st: *mut OpusMSDecoder,
        Fs: opus_int32,
        channels: ::std::os::raw::c_int,
        streams: ::std::os::raw::c_int,
        coupled_streams: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode a multistream Opus packet.\n @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state.\n @param[in] data <tt>const unsigned char*</tt>: Input payload.\n                                                Use a <code>NULL</code>\n                                                pointer to indicate packet\n                                                loss.\n @param len <tt>opus_int32</tt>: Number of bytes in payload.\n @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved\n                                       samples.\n                                       This must contain room for\n                                       <code>frame_size*channels</code>\n                                       samples.\n @param frame_size <tt>int</tt>: The number of samples per channel of\n                                 available space in \\a pcm.\n                                 If this is less than the maximum packet duration\n                                 (120 ms; 5760 for 48kHz), this function will not be capable\n                                 of decoding some packets. In the case of PLC (data==NULL)\n                                 or FEC (decode_fec=1), then frame_size needs to be exactly\n                                 the duration of audio that is missing, otherwise the\n                                 decoder will not be in the optimal state to decode the\n                                 next incoming packet. For the PLC and FEC cases, frame_size\n                                 <b>must</b> be a multiple of 2.5 ms.\n @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band\n                                 forward error correction data be decoded.\n                                 If no such data is available, the frame is\n                                 decoded as if it were lost.\n @returns Number of samples decoded on success or a negative error code\n          (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_decode(
        st: *mut OpusMSDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut opus_int16,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode a multistream Opus packet with floating point output.\n @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state.\n @param[in] data <tt>const unsigned char*</tt>: Input payload.\n                                                Use a <code>NULL</code>\n                                                pointer to indicate packet\n                                                loss.\n @param len <tt>opus_int32</tt>: Number of bytes in payload.\n @param[out] pcm <tt>opus_int16*</tt>: Output signal, with interleaved\n                                       samples.\n                                       This must contain room for\n                                       <code>frame_size*channels</code>\n                                       samples.\n @param frame_size <tt>int</tt>: The number of samples per channel of\n                                 available space in \\a pcm.\n                                 If this is less than the maximum packet duration\n                                 (120 ms; 5760 for 48kHz), this function will not be capable\n                                 of decoding some packets. In the case of PLC (data==NULL)\n                                 or FEC (decode_fec=1), then frame_size needs to be exactly\n                                 the duration of audio that is missing, otherwise the\n                                 decoder will not be in the optimal state to decode the\n                                 next incoming packet. For the PLC and FEC cases, frame_size\n                                 <b>must</b> be a multiple of 2.5 ms.\n @param decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band\n                                 forward error correction data be decoded.\n                                 If no such data is available, the frame is\n                                 decoded as if it were lost.\n @returns Number of samples decoded on success or a negative error code\n          (see @ref opus_errorcodes) on failure."]
    pub fn opus_multistream_decode_float(
        st: *mut OpusMSDecoder,
        data: *const ::std::os::raw::c_uchar,
        len: opus_int32,
        pcm: *mut f32,
        frame_size: ::std::os::raw::c_int,
        decode_fec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform a CTL function on a multistream Opus decoder.\n\n Generally the request and subsequent arguments are generated by a\n convenience macro.\n @param st <tt>OpusMSDecoder*</tt>: Multistream decoder state.\n @param request This and all remaining parameters should be replaced by one\n                of the convenience macros in @ref opus_genericctls,\n                @ref opus_decoderctls, or @ref opus_multistream_ctls.\n @see opus_genericctls\n @see opus_decoderctls\n @see opus_multistream_ctls"]
    pub fn opus_multistream_decoder_ctl(
        st: *mut OpusMSDecoder,
        request: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Frees an <code>OpusMSDecoder</code> allocated by\n opus_multistream_decoder_create().\n @param st <tt>OpusMSDecoder</tt>: Multistream decoder state to be freed."]
    pub fn opus_multistream_decoder_destroy(st: *mut OpusMSDecoder);
}
